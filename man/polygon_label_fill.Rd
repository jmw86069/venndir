% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/venndir-polygon-label-fill.R
\name{polygon_label_fill}
\alias{polygon_label_fill}
\title{Arrange text labels inside a polygon}
\usage{
polygon_label_fill(
  sp,
  labels,
  color = "black",
  border = NA,
  ref_sp = NULL,
  fontsize = 10,
  cex = 1,
  degrees = 0,
  dither_cex = 0.04,
  dither_color = 0.07,
  dither_degrees = 0,
  scale_width = -0.15,
  apply_n_scale = TRUE,
  buffer_w = 0,
  buffer_h = 0,
  label_method = c("hexagonal", "nonaligned", "regular", "random", "stratified",
    "clustered"),
  layout_degrees = -20,
  draw_buffer = FALSE,
  buffer_fill = "#FFFFFF77",
  buffer_border = "red",
  draw_points = FALSE,
  draw_labels = TRUE,
  seed = NULL,
  plot_style = c("base", "gg", "none"),
  verbose = FALSE,
  ...
)
}
\arguments{
\item{sp}{object \code{sp::SpatialPolygons}}

\item{labels}{\code{character} vector of labels, the length defines
the number of coordinate positions to return.}

\item{color}{\code{vector} of R compatible colors which defines the
color of each label.}

\item{border}{\code{vector} or \code{NA} with colors to define the border around
each label.}

\item{ref_sp}{object \code{sp::SpatialPolygons} used as a reference to
compare the size of \code{sp} when \code{apply_n_scale=TRUE}. In general,
fewer labels are placed more toward the center; also in general,
this effect is applied less for smaller polygons.}

\item{fontsize}{\code{numeric} value indicating the font size in points.}

\item{cex}{\code{numeric} value used to resize all text labels by
multiplying the font size.}

\item{degrees}{\code{numeric} \code{vector} indicating the angle in degrees
to rotate each text label, where positive values rotate
in clockwise direction.}

\item{dither_cex}{\code{numeric} or \code{NULL}, where a numeric value
is applied to \code{cex} in random fashion to provide some
visual heterogeneity in the \code{cex} for item labels. When
\code{dither_cex=0} or \code{dither_cex=NULL} then no adjustment
is performed.}

\item{dither_color}{\code{numeric} or \code{NULL}, where a numeric value
is use to adjust each \code{color} slightly lighter or darker
via \code{jamba::makeColorDarker()}. The effect is to make adjacent
labels visibly different but in a subtle way.}

\item{dither_degrees}{\code{numeric} or \code{NULL}, where a numeric value
is used to adjust the text angle slightly more or less that
the \code{degrees} value.}

\item{scale_width}{\code{numeric} value or \code{NULL}, where a numeric
value indicates the relative size of the polygon to use as
a buffer around the polygon, and should be given as
negative values. For example \code{scale_width=-0.1} will create
a buffer at 10\% the size of the polygon.}

\item{apply_n_scale}{\code{logical} indicating whether to adjust the
polygon buffer based upon the number of labels, specifically
so that few labels (1, 2, or 3 labels) have much higher buffer
and therefore are positioned more central inside the polygon.}

\item{buffer_w, buffer_h}{\code{numeric} width and height, respectively,
used for additional buffer inside each polygon. These values
are appropriate when the width of text label is known. The
buffer polygon derived from \code{scale_width} and \code{apply_n_scale}
is moved left, right, up, down, and the intersection of these
operations is used with \code{sp::spsample()} to define label
positions. In this way, labels should fit inside the original
polygon without overlapping the boundary. This function does
not define default values, because the actual text label width
is dependent upon the diplay device properties at the time
the plot is drawn, and this device may not even be open when
this function is called.}

\item{label_method}{\code{character} string indicating the layout type
used by \code{sp::spsample()}.}

\item{draw_buffer}{\code{logical} indicating whether the buffer polygon
should be drawn, intended for visual review of the processing.}

\item{buffer_fill, buffer_border}{color values used when \code{draw_buffer=TRUE}.}

\item{draw_points}{\code{logical} indicating whether to draw points at
each coordinate position, intended for visual review of the processing.}

\item{draw_labels}{\code{logical} indicating whether to draw text labels
which is performed using \code{gridtext::richtext_grob()} inside
a base R plot.}

\item{seed}{\code{numeric} or \code{NULL}, where a \code{numeric} value is
passed to \code{set.seed()} to make the \code{dither_cex} process reproducible.
Set \code{seed=NULL} to disable this step.}

\item{plot_style}{\code{character} string indicating the expected output
plot style: \code{"base"} uses base R graphics, \code{gridtext::richtext_grob()};
\code{"gg"} uses \code{ggplot2} style; \code{"none"} does not plot anything.}

\item{verbose}{\code{logical} indicating whether to print verbose output.}
}
\value{
\code{list} that contains: \code{items_df} as a \code{data.frame} of item
label coordinates; and \code{g_labels} as output from
\code{gridtext::richtext_grob()} whose coordinates are defined
as \code{"native"}, or \code{g_labels=NULL} when \code{plot_style="gg"};
\code{scale_width} with the \code{numeric} value used; and
\code{sp_buffer} with the \code{sp::SpatialPolygons} object representing
the buffer region used for item labels.
}
\description{
Arrange text labels inside a polygon
}
\details{
This function takes a vector of text labels, and will
arrange those labels to fill the inside of a polygon.
Currently the method uses \code{sp::spsample()} which
has a few algorithms to generate point positions
inside a polygon, and these positions are used to
anchor text labels. Currently this method does no
overlap detection.

The primary method to avoid overlap is to use
\code{label_method="hexagon"} and \code{degrees=20}, since hexagonal
layout tends to have points at roughly 0 and 60 degrees
from one another, and 20 degree rotation tends to allow
text labels to nestle beside each other without much
overlap.
}
\examples{
sp <- sp_ellipses(3, 3, xradius=1.2, yradius=3, rotation_degrees=15)
words <- jamba::unvigrep("[0-9]",
   jamba::vigrep("[a-zA-Z]", 
      unique(unlist(
      strsplit(as.character(packageDescription("venndir")),
      '[", _()<>:;/\n\t.@&=]+')))));
words <- words[nchar(words) > 2];
plot(sp, col="gold", border="gold4", lwd=2);
polygon_label_fill(sp=sp,
   degrees=-10,
   labels=words,
   dither_color=0.2,
   color="red2",
   cex=1.2)

plot(sp, col="gold", border="gold4", lwd=2);
polygon_label_fill(sp=sp,
   degrees=0,
   draw_buffer=FALSE,
   layout_degrees=45/2,
   buffer_w=0.4,
   label_method="regular",
   labels=jamba::mixedSort(words),
   dither_color=0.2,
   dither_cex=0.2,
   dither_degrees=0,
   color="red2",
   cex=1.2)

# iterate various options for reducing label overlap
par("mfrow"=c(2, 4));
for (lm in c("hexagonal", "regular")) {
for (ld in c(0, -45/2, -30, -45)) {
plot(sp, col="gold", border="gold4", lwd=2);
id <- ifelse(ld == 0, -20,
   ifelse(ld == -45, 15, 0));
polygon_label_fill(sp=sp,
   degrees=id,
   layout_degrees=ld,
   buffer_w=0.4,
   label_method=lm,
   #labels=seq_along(words),
   #labels=rep("word", length(words)),
   labels=paste0("word", seq_along(words)),
   dither_color=0,
   dither_cex=0,
   dither_degrees=0,
   color="navy",
   cex=0.7)
title(main=paste0("layout_degrees=",
   format(ld, digits=2),
   "\nlabel_method='", lm, "'",
   "\ndegrees=", id));
}
}
par("mfrow"=c(1, 1));

plot(sp, col="gold", border="gold4", lwd=2);
polygon_label_fill(sp=sp,
   degrees=-10,
   scale_width=-0.3,
   draw_buffer=TRUE,
   labels=words, dither_color=0.2, color="red2", cex=1.2)

setlist <- make_venn_test(100, 3);
vo <- venndir(setlist, return_items=TRUE, font_cex=0.01, proportional=FALSE);

# labels inside each venn overlap polygon
venn_spdf <- vo$venn_spdf;
label_df <- vo$label_df;
for (i in seq_len(nrow(venn_spdf))) {
   j <- match(venn_spdf$label[i], label_df$overlap_set);
   if (length(unlist(label_df[j,"items"])) > 0) {
   polygon_label_fill(sp=venn_spdf[i,],
      ref_sp=venn_spdf,
      color=venn_spdf$border[i],
      scale_width=-0.1,
      draw_buffer=TRUE,
      labels=unlist(label_df[j,"items"]));
   }
}

# same example as above but using proportional circles
vo <- venndir(setlist, font_cex=0.01, proportional=TRUE);

# labels inside each venn overlap polygon
venn_spdf <- vo$venn_spdf;
label_df <- vo$label_df;
for (i in seq_len(nrow(venn_spdf))) {
   j <- match(venn_spdf$label[i], label_df$overlap_set);
   if (length(unlist(label_df[j,"items"])) > 0) {
   polygon_label_fill(sp=venn_spdf[i,],
      ref_sp=venn_spdf,
      color=venn_spdf$border[i],
      scale_width=-0.1,
      draw_buffer=TRUE,
      labels=unlist(label_df[j,"items"]));
   }
}


}
\seealso{
Other venndir label: 
\code{\link{draw_gridtext_groups}()},
\code{\link{polygon_label_outside}()},
\code{\link{polygon_label_segment}()},
\code{\link{polygon_list_label_segment}()},
\code{\link{reposition_venn_gridtext_labels}()},
\code{\link{sp_polylabelr}()}
}
\concept{venndir label}
