% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/venndir-polygon-list-label-segment.R
\name{polygon_list_label_segment}
\alias{polygon_list_label_segment}
\title{Define a polygon label line segment}
\usage{
polygon_list_label_segment(
  x0,
  x1,
  y0,
  y1,
  polygon_list,
  return_class = c("point", "matrix"),
  buffer = 0,
  plot_debug = FALSE,
  relative = TRUE,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x0}{\code{numeric} x-axis source position}

\item{x1}{\code{numeric} x-axis target position}

\item{y0}{\code{numeric} y-axis source position}

\item{y1}{\code{numeric} y-axis target position}

\item{polygon_list}{\code{list} with \code{"x"} and \code{"y"} elements}

\item{return_class}{\code{character} string
\itemize{
\item \code{"point"} returns a \code{matrix} with one row containing the new
target point;
\item \code{"matrix"} contains two rows with source and new target points
}}

\item{buffer}{\code{numeric} indicating an optional buffer to
use for the \code{sp} polygon. By default \code{sp_buffer=0} uses no
buffer, but a suggested buffer \code{sp_buffer=-0.01} would make
the polygon \verb{1\%} smaller, therefore the line segment would be
slightly inside the polygon border.}

\item{relative}{\code{logical} indicating whether \code{sp_buffer} is scaled
relative to the size of the polygon, see \code{get_sp_buffer()}
for more details.}

\item{verbose}{\code{logical} indicating whether to print verbose output,
specifically describing which situation occurred.}

\item{...}{additional arguments are passed to \code{get_sp_buffer()}.}
}
\value{
\code{numeric} matrix with one row, representing the
point of intersection with the polygon boundary,
see comments above for exceptions. When
\code{return_class="matrix"} then the \code{matrix} contains
two rows, where the second row contains the
point of intersection. When \code{return_class="SpatialLines"}
the object is \code{sp::SpatialLines} and represents the
line from the first point and the point of intersection.
Note that when there is no second point, the
\code{sp::SpatialLines} object will only have one point.
}
\description{
Define a polygon label line segment
}
\details{
This function takes a line segment and polygon, and
returns the point where a line segment starting
at the source point touches the outer boundary of
the polygon.

This function is intended to be used with polygon
labels, where the original label position
is inside the polygon, but is manually adjusted
and may be placed somewhere outside the polygon.
This function finds a suitable point to draw a line
segment from the new label position to the polygon.

Some different situations are handled as follows,
use \code{verbose=TRUE} to see which situation occurred.
\itemize{
\item When the starting point is outside the polygon,
and end point is inside the polygon, this function
finds the point where this line segment first
intersects the polygon boundary. This is the
driving reason for this function.
\item When the starting point is outside the polygon,
and end point also outside the polygon, this function
finds the nearest the nearest point along
the polygon boundary.
\item When the starting point is inside the polygon,
this function returns NULL.
}

Note that this function currently does not adjust for
the size or position of a label.
}
\examples{
x0 <- 0;x1 <- 1;y0 <- 0; y1 <- 1;
sp <- polygon_ellipses(xcenter=1, ycenter=1, xradius=0.5, yradius=1)
par("xpd"=TRUE)
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp,
   return_class="matrix",
   plot_debug=TRUE,
   main="segment drawn to boundary intersection");
text(x=sl2[1, 1], y=sl2[1, 2],
   labels="adjusted label",
   cex=2,
   adj=sl2[1, c("adjx", "adjy")])

# example of making a debug plot
lxy <- cbind(c(x0, x1), c(y0, y1));
sp <- polygon_ellipses(xcenter=1, ycenter=1, xradius=0.5, yradius=1);
plot_polygon_list(sp, col="#00007777", border="blue3", lwd=2,
   xlim=c(0, 2), ylim=c(0, 2), asp=1,
   main="segment drawn to boundary intersection");
plot_polygon_list(list(list(x=sl2[, "x"], y=sl2[, "y"])), border="red3", lwd=4, add=TRUE)

# example where the line intersects multiple boundaries
x0 <- 0;x1 <- 2;y0 <- 0; y1 <- 2;
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp,
   return_class="matrix",
   plot_debug=TRUE,
   verbose=TRUE,
   main="segment drawn to first boundary intersection");

# example where starting line does not intersect
x0 <- 0;x1 <- 1;y0 <- 0; y1 <- 1;
sp <- polygon_ellipses(xcenter=2, ycenter=1, xradius=0.5, yradius=1);
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp,
   return_class="matrix",
   plot_debug=TRUE,
   xlim=c(0, 3),
   main="segment drawn to nearest boundary point");

# example showing line fully inside the polygon
x0 <- 0;x1 <- 2;y0 <- 0; y1 <- 2;
sp <- polygon_ellipses(xcenter=1, ycenter=1, xradius=1.5, yradius=2.2);
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp,
   return_class="matrix",
   plot_debug=TRUE,
   main="segment contained inside returns one point");

# example showing polygon with a hole inside
# TODO: Fix polyclip generating a polygon with hole inside
sp <- polygon_ellipses(xcenter=1, ycenter=1, xradius=0.5, yradius=1);
sp_hole <- polygon_ellipses(xcenter=1, ycenter=1, xradius=0.2, yradius=0.5);
plot_polygon_list(list(sp, sp_hole), col=c("red", "blue"))
sp_donut <- minus_polygon_list(c(sp, sp_hole));
plot_polygon_list(sp_donut, col=jamba::alpha2col("gold", 0.5))
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp_donut,
   return_class="matrix",
   plot_debug=TRUE,
   main="segment drawn to first outer boundary intersection");

# example with line inside the polygon hole
x0 <- 0.9;x1 <- 1.1;y0 <- 0.9; y1 <- 1.1;
sp <- polygon_ellipses(xcenter=1, ycenter=1, xradius=0.5, yradius=1);
sp_hole <- polygon_ellipses(xcenter=1, ycenter=1, xradius=0.2, yradius=0.5);
sp_donut <- minus_polygon_list(sp, sp_hole);
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp_donut,
   return_class="matrix",
   plot_debug=TRUE,
   main="segment drawn to nearest boundary");

# line crosses inside the polygon hole
x0 <- 1;x1 <- 1.4;y0 <- 1; y1 <- 1.4;
sp <- sp_ellipses(xcenter=1, ycenter=1, xradius=0.5, yradius=1);
sp_hole <- sp_ellipses(xcenter=1, ycenter=1, xradius=0.2, yradius=0.5);
sp_donut <- rgeos::gDifference(sp, sp_hole);
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp_donut,
   return_class="matrix",
   plot_debug=TRUE,
   main="segment drawn to boundary intersection");

x0 <- 0.6;x1 <- 1;y0 <- 0.6; y1 <- 1;
sp <- sp_ellipses(xcenter=1, ycenter=1, xradius=0.5, yradius=1);
sp_hole <- sp_ellipses(xcenter=1, ycenter=1, xradius=0.2, yradius=0.5);
sp_donut <- rgeos::gDifference(sp, sp_hole);
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp_donut,
   return_class="matrix",
   plot_debug=TRUE,
   main="first point inside the polygon, returns one point");

# example showing multiple input points
x0 <- c(0.6, 1.1);
x1 <- c(1, 1.4);
y0 <- c(0.6, 1.1);
y1 <- c(1, 1.4);
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp=sp_donut,
   return_class="point", verbose=TRUE, plot_debug=TRUE); 

# example showing sp_buffer
sl2 <- polygon_list_label_segment(x0, x1, y0, y1, sp=sp_donut,
   sp_buffer=-0.1,
   return_class="point", verbose=TRUE, plot_debug=TRUE); 

}
\seealso{
Other venndir label: 
\code{\link{draw_gridtext_groups}()},
\code{\link{polygon_label_fill}()},
\code{\link{polygon_label_outside}()},
\code{\link{polygon_label_segment}()},
\code{\link{reposition_venn_gridtext_labels}()},
\code{\link{sp_polylabelr}()}
}
\concept{venndir label}
