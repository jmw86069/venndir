% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/venndir-test.R
\name{make_venn_test}
\alias{make_venn_test}
\title{Generate test sets for venndir}
\usage{
make_venn_test(
  n_items = 1e+06,
  n_sets = 4,
  min_size = ceiling(n_items/1000),
  max_size = ceiling(n_items/2),
  do_signed = FALSE,
  items = NULL,
  sizes = NULL,
  seed = 123,
  ...
)
}
\arguments{
\item{n_items}{\code{integer} total number of items available
to all sets, also known as the universe size.}

\item{n_sets}{\code{integer} number of sets that contain items.}

\item{min_size}{\code{integer} minimum range of items that may
be contained in each set.}

\item{max_size}{\code{integer} maximum range of items that may
be contained in each set.}

\item{do_signed}{\code{logical} indicating whether to return signed
sets, which indicate directionality with \code{-1} or \code{1} values,
named by the items.}

\item{items}{\code{vector} or \code{NULL} that contains the universe
of items. When \code{items} is defined, \code{n_items} is ignored.}

\item{sizes}{\code{vector} of \code{integer} values, or \code{NULL}, indicating
the size of each set. When \code{sizes} is defined, \code{min_size} and
\code{max_size} is ignored. When \code{sizes} is defined, \code{names(sizes)}
are used as names for each set.}

\item{seed}{\code{numeric} or \code{NULL} used with \code{set.seed()} for data
reproducibility. When \code{seed=NULL} then \code{set.seed()} is not called.}

\item{...}{additional arguments are ignored.}
}
\value{
\code{list} of items, either as a list of item vectors,
or when \code{do_signed=TRUE} the list of vectors, where vector
names contain the items, and vector values are signed values
from \code{c(-1, 1)}.
}
\description{
Generate test sets for venndir
}
\details{
This function generates data to use as test input to
Venn diagram functions. It can generate sets of items,
or signed sets (integer values \code{-1}, \code{1}) named by
item.

This function defines a range of set sizes, using \code{min_size}
and \code{max_size}, with roughly square-root sequence of sizes
between these two extremes.

Note that the universe size represents the total available
items, but not necessarily the total number of items
represented by the sets. For example, if \code{n_items=1000000},
\code{max_size=500} and \code{n_sets=3} then the maximum number of
items actually represented is \code{1500}.

The universe can be defined using optional argument \code{items},
which takes priority over \code{n_items}.

The specific size of each set can be defined with optional
argument \code{sizes}, which takes priority over \code{min_size}, and
\code{max_size}.
}
\examples{
set_list <- make_venn_test(n_items=100,
   n_sets=3,
   min_size=5,
   max_size=25)
set_im <- list2im_opt(set_list);
pryr::object_size(set_im)
pryr::object_size(as.matrix(set_im)*1)
head(set_im)
table(jamba::pasteByRow(as.matrix(set_im)*1))

set_list <- make_venn_test()
jamba::sdim(set_list);
sv1 <- signed_overlaps(setlist=set_list, "overlap")
sv2 <- signed_overlaps(setlist=set_list, "each")
sv3 <- signed_overlaps(setlist=set_list, "concordant")

set_im <- list2im_opt(set_list)
dim(set_im)
head(set_im)

set_lists <- make_venn_test(n_items=100, do_signed=TRUE)
jamba::sdim(set_lists);
set_ims <- list2im_signed(set_lists, do_sparse=TRUE);
dim(set_ims);
head(set_ims);


svs1 <- signed_overlaps(setlist=set_lists, "overlap")
svs2 <- signed_overlaps(setlist=set_lists, "each")
svs3 <- signed_overlaps(setlist=set_lists, "concordance")
svs4 <- signed_overlaps(setlist=set_lists, "concordant")

sv <- signed_overlaps(set_lists, "overlap")
jamba::nameVector(sv[,c("count","overlap_set")])

sv_each <- slicejam::signed_venn(set_lists, "each")
jamba::ssdim(sv_each)
sv_each_counts_df <- jamba::rbindList(lapply(names(sv_each$Venn_Counts), function(i){
   idf <- sv_each$Venn_Counts[[i]];
   idf$set <- i;
   idf$sign <- rownames(idf);
   idf$nz_sign <- gsub("[ ]+", " ",
      gsub("0", "", idf$sign));
   idf[,c("set","sign","count","nz_sign"),drop=FALSE];
}))
head(sv_each_counts_df,20)

sv_concordance <- slicejam::signed_venn(set_lists, "concordance")
jamba::ssdim(sv_concordance)
sv_concordance$Venn_Counts

sv_concordant <- slicejam::signed_venn(set_lists, "concordant")
jamba::ssdim(sv_concordant)
sv_concordant$Venn_Counts

}
\seealso{
Other venndir utility: 
\code{\link{curate_venn_labels}()},
\code{\link{eulerr2polys}()},
\code{\link{get_venn_shapes}()},
\code{\link{nudge_sp}()},
\code{\link{print_color_df}()},
\code{\link{shrink_df}()}
}
\concept{venndir utility}
