% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/venndir-label-fill-jp.R
\name{label_fill_JamPolygon}
\alias{label_fill_JamPolygon}
\title{Arrange text labels inside a polygon}
\usage{
label_fill_JamPolygon(
  jp,
  labels,
  buffer = -0.15,
  width_buffer = 0.1,
  relative = TRUE,
  color = "black",
  border = NA,
  ref_jp = NULL,
  xyratio = 1.1,
  fontsize = 10,
  cex = 1,
  degrees = 0,
  jitter_cex = 0.04,
  jitter_color = 0.07,
  jitter_degrees = 0,
  apply_n_scale = TRUE,
  label_method = c("offset", "columns"),
  draw_labels = TRUE,
  seed = 1,
  plot_style = c("none", "JamPolygon"),
  verbose = FALSE,
  ...
)
}
\arguments{
\item{jp}{\code{JamPolygon} where only the first row is processed.}

\item{labels}{\code{character} vector of labels}

\item{buffer}{\code{numeric} value (default \code{-0.15}) buffer to resize the
polygon, where negative values shrink the polygon size relative
to the size of the polygon. For example \code{-0.9} will reduce the polygon
90\% of the way toward a completely empty polygon, where that range
is defined by the width inside the polygon border.}

\item{width_buffer}{\code{numeric} passed to \code{sample_JamPolygon()} to apply
a "width buffer", using values relative to the maximum \code{buffer}
size. This mechanism is experimental, to try to improve label
placement in unusually-shaped polygons.
\itemize{
\item \code{width_buffer=0} will add no additional buffer
\item \code{width_buffer=0.5} will apply width buffer equal to half the
buffer size required to create an empty polygon. The polygon is
shifted left and right by half this amount each direction, then
the intersection is used. This method has the intention of requiring
a certain available width, for example for wide text labels.
}}

\item{relative}{\code{logical} passed to \code{buffer_JamPolygon()} (default \code{TRUE})
to define \code{buffer} with relative coordinates.}

\item{color}{\code{character} string to define the color of resulting labels.}

\item{border}{\code{character} string used to define an optional item border,
which is only useful when \code{gridtext} is used to visualize labels.}

\item{ref_jp}{\code{JamPolygon} (optional) used only when \code{apply_n_scale=TRUE},
used to define the overall plot range before determining whether
the internal area of \code{jp} should be reduced before arraying item
label coordinates.
The general idea is that polygons which are a smaller percentage
of the total area should not be reduced as much by \code{apply_n_scale}
because they have limited area, but larger polygons should receive
closer to the full \code{apply_n_scale} adjustment.}

\item{xyratio}{\code{numeric} value indicating the relative ratio of x (width)
to y (height) when arraying coordinates inside the polygons.
Values larger than \code{1} will place points wider from each other than
they are tall, which can help with longer text labels.}

\item{fontsize}{\code{numeric} font size in points, default \code{10}.}

\item{cex}{\code{numeric} multiplied by \code{fontsize} as an alternative convenient
way to adjust text label sizes.}

\item{degrees}{\code{numeric} value used to rotate labels, default \code{0},
in degrees between 0 and 359.}

\item{apply_n_scale}{\code{logical} indicating whether to adjust the buffer
based upon the number of items, where more items uses less buffer,
and fewer items imposes a larger buffer.
The intent is for a single label or small number of labels to
appear near the center.}

\item{label_method}{\code{character} string (default "hexagonal") to define
the label layout. Passed as \code{pattern} to \code{sample_JamPolygon()}.
\itemize{
\item \code{"offset"} implements close to hexagonal/triangular arrangement,
with adjustable xy ratio via argument \code{xyratio}. Every other point
is "offset" upward by half the row height.
\item \code{"columns"} implements effectively the same approach with no
y-offset, so that items are always in proper rectangular grid format.
Preferred for column-organization, and typically works best with
larger \code{xyratio} values.
}}

\item{draw_labels}{\code{logical} (default \code{TRUE}) indicating whether to
draw labels, however it is only used when \code{plot_style="JamPolygon"}.
Note also, when drawing labels, it assumes the plot is already
created using \code{ref_jp}, and it determines the coordinate
adjustments relative to \code{ref_jp}.}

\item{seed}{\code{numeric} value (default \code{1}) used to define the random seed
with \code{set.seed(seed)} for reproducible output.
When \code{seed} is \code{NULL} there is no call to \code{set.seed()}.}

\item{plot_style}{\code{character} string, default "none".
\itemize{
\item \code{"none"}: No plot output.
\item \code{"JamPolygon"}: assume \code{ref_jp} has already been plotted, and
labels should be drawn in that coordinate context.
For example call \code{plot(ref_jp)} then
\code{label_fill_JamPolygon(jp, ref_jp, plot_output="JamPolygon")}.
See examples.
}}

\item{verbose}{\code{logical} indicating whether to print verbose output.}

\item{...}{additional arguments are passed to internal functions:
\code{buffer_JamPolygon()}, and \code{sample_JamPolygon()}.}

\item{`jitter_cex, jitter_color, jitter_degrees`}{values used to provide
some variability to the repeated pattern of text labels.
\itemize{
\item \code{jitter_cex} provides a range to adjust \code{cex} and \code{fontsize} slightly
for each label, making some slightly larger or smaller to help
distinguish adjacent labels from one another.
\item \code{jitter_color} provides a range for adjusting the font color, which
is applied with \code{darkFactor} in \code{jamba::makeColorDarker()}.
\item \code{jitter_degrees} provides a range for adjusting font \code{degrees},
the default \code{0} means the values are not adjusted. The \code{text()} function
does not permit multiple vectorized rotations, however \code{gridtext}
does permit multiple angles. Best to use \code{jitter_degrees} only
when displaying labels with \code{gridtext}.
}}
}
\value{
\code{list} when there are valid coordinates, \code{NULL} otherwise.
The \code{list} contains these elements:
\itemize{
\item \code{"items_df"}: a \code{data.frame} with columns
\verb{x,y,text,rot,color,fontsize,border}
\item \code{"g_labels"}: a grid \code{grob} graphical object only when
\code{plot_style="base"}, otherwise \code{NULL}
\item \code{"scale_width"}: a \code{numeric} value indicating the \code{buffer} used
\item \code{"jp_buffer"}: a \code{JamPolygon} object after adjusting with \code{buffer}
}
}
\description{
Arrange one or more text labels to fit inside a polygon.
}
\details{
This function is intended to define points inside a polygon area
so that text labels can be roughly evenly spaced, with relatively
good default positioning to minimize overlapping labels.
This function does not prevent overlapping labels, nor does it
fully prevent labels overlapping the polygon border.

There are options to help minimize overlapping labels, such as \code{xyratio}
which defines the default width-to-height ratio of resulting points.
For wider text labels, a higher value for \code{xyratio} may be helpful.
To minimize adjacent (side-by-side) label overlaps, it can be helpful
to use \code{degrees} to rotate labels slightly, for example \code{degrees=5}
may be enough to prevent wide labels from overlapping the next label
beside it.
\subsection{Strategy}{
\itemize{
\item Determine bounding box with rectangular area that encompases the polygon.
\item Define evenly spaced points across the rectangular area sufficient
to produce at least \code{n} total points.
\item Retain only the subset of points which are inside the polygon.
\item If there are fewer than \code{n} remaining points, repeat the process
using a higher target value for \code{n}.
}
}

\subsection{Todo}{
\itemize{
\item Modify options that plot the result so they work together with
\code{plot.JamPolygon()}.
}
}
}
\examples{
df3 <- data.frame(name=c("polygon1", "polygon2"),
   label=c("polygon1", "polygon2"),
   x=I(list(
      list(c(1, 6, 6, 1),
         c(2, 5, 5, 2),
         c(3, 4, 4, 3)),
      list(#c(11, 16, 16, 11),
         c(12, 15, 15, 12),
         c(13, 14, 14, 13))
      )),
   y=I(list(
      list(c(1, 1, 6, 6),
         c(2, 2, 5, 5),
         c(3, 3, 4, 4)),
      list(#c(1, 1, 6, 6),
         c(2, 2, 5, 5),
         c(3, 3, 4, 4))
      )),
   fill=c("gold", "firebrick"))
jp3 <- new("JamPolygon", polygons=df3);

jp3p <- plot(jp3);

lfj1 <- label_fill_JamPolygon(jp3[1,], labels=rep("O", 100),
   ref_jp=jp3, plot_style="JamPolygon")
lfj2 <- label_fill_JamPolygon(jp3[2,], labels=rep("X", 40),
   buffer=-0.5,
   label_method="columns",
   ref_jp=jp3, plot_style="JamPolygon")

jp3p <- plot(jp3);
lfj1 <- label_fill_JamPolygon(jp3[1,], labels=rep("O", 87),
   apply_n_scale=FALSE,
   spread=TRUE,
   ref_jp=jp3, plot_style="JamPolygon")

}
\seealso{
Other JamPolygon: 
\code{\link{JamPolygon-class}},
\code{\link{Venndir-class}},
\code{\link{[,JamPolygon,ANY,ANY,ANY-method}},
\code{\link{add_orientation_JamPolygon}()},
\code{\link{area_JamPolygon}()},
\code{\link{bbox_JamPolygon}()},
\code{\link{buffer_JamPolygon}()},
\code{\link{check_JamPolygon}()},
\code{\link{check_Venndir}()},
\code{\link{eulerr_to_JamPolygon}()},
\code{\link{farthest_point_JamPolygon}()},
\code{\link{find_venn_overlaps_JamPolygon}()},
\code{\link{has_point_in_JamPolygon}()},
\code{\link{intersect_JamPolygon}()},
\code{\link{label_outside_JamPolygon}()},
\code{\link{label_segment_JamPolygon}()},
\code{\link{labelr_JamPolygon}()},
\code{\link{minus_JamPolygon}()},
\code{\link{nearest_point_JamPolygon}()},
\code{\link{nudge_JamPolygon}()},
\code{\link{plot.JamPolygon}()},
\code{\link{point_in_JamPolygon}()},
\code{\link{polyclip_to_JamPolygon}()},
\code{\link{polygon_circles}()},
\code{\link{polygon_ellipses}()},
\code{\link{sample_JamPolygon}()},
\code{\link{split_JamPolygon}()},
\code{\link{union_JamPolygon}()},
\code{\link{update_JamPolygon}()}
}
\concept{JamPolygon}
